#
# Copyright (C) 2008 The Android Open Source Project
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

<<<<<<< HEAD
# Catch users that directly include base_rules.mk
$(call record-module-type,base_rules)

=======
>>>>>>> 1b0db93f (Merge pull request #122 from kanru/bug1031593)
# Users can define base-rules-hook in their buildspec.mk to perform
# arbitrary operations as each module is included.
ifdef base-rules-hook
$(if $(base-rules-hook),)
endif

###########################################################
## Common instructions for a generic module.
###########################################################

LOCAL_MODULE := $(strip $(LOCAL_MODULE))
ifeq ($(LOCAL_MODULE),)
  $(error $(LOCAL_PATH): LOCAL_MODULE is not defined)
endif
<<<<<<< HEAD
$(call verify-module-name)

LOCAL_IS_HOST_MODULE := $(strip $(LOCAL_IS_HOST_MODULE))
LOCAL_IS_AUX_MODULE := $(strip $(LOCAL_IS_AUX_MODULE))
=======

LOCAL_IS_HOST_MODULE := $(strip $(LOCAL_IS_HOST_MODULE))
>>>>>>> 1b0db93f (Merge pull request #122 from kanru/bug1031593)
ifdef LOCAL_IS_HOST_MODULE
  ifneq ($(LOCAL_IS_HOST_MODULE),true)
    $(error $(LOCAL_PATH): LOCAL_IS_HOST_MODULE must be "true" or empty, not "$(LOCAL_IS_HOST_MODULE)")
  endif
<<<<<<< HEAD
  ifeq ($(LOCAL_HOST_PREFIX),)
    my_prefix := HOST_
  else
    my_prefix := $(LOCAL_HOST_PREFIX)
  endif
  my_host := host-
  my_kind := HOST
else
  ifdef LOCAL_IS_AUX_MODULE
    ifneq ($(LOCAL_IS_AUX_MODULE),true)
      $(error $(LOCAL_PATH): LOCAL_IS_AUX_MODULE must be "true" or empty, not "$(LOCAL_IS_AUX_MODULE)")
    endif
    my_prefix := AUX_
    my_kind := AUX
  else
    my_prefix := TARGET_
    my_kind :=
  endif
  my_host :=
endif

ifeq ($(my_prefix),HOST_CROSS_)
  my_host_cross := true
else
  my_host_cross :=
endif

ifeq (true, $(LOCAL_PRODUCT_MODULE))
ifneq (,$(filter $(LOCAL_MODULE),$(PRODUCT_FORCE_PRODUCT_MODULES_TO_SYSTEM_PARTITION)))
  LOCAL_PRODUCT_MODULE :=
endif
endif

_path := $(LOCAL_MODULE_PATH) $(LOCAL_MODULE_PATH_32) $(LOCAL_MODULE_PATH_64)
ifneq ($(filter $(TARGET_OUT_VENDOR)%,$(_path)),)
LOCAL_VENDOR_MODULE := true
else ifneq ($(filter $(TARGET_OUT_OEM)/%,$(_path)),)
LOCAL_OEM_MODULE := true
else ifneq ($(filter $(TARGET_OUT_ODM)/%,$(_path)),)
LOCAL_ODM_MODULE := true
else ifneq ($(filter $(TARGET_OUT_PRODUCT)/%,$(_path)),)
LOCAL_PRODUCT_MODULE := true
else ifneq ($(filter $(TARGET_OUT_PRODUCT_SERVICES)/%,$(_path)),)
LOCAL_PRODUCT_SERVICES_MODULE := true
endif
_path :=

ifndef LOCAL_PROPRIETARY_MODULE
  LOCAL_PROPRIETARY_MODULE := $(LOCAL_VENDOR_MODULE)
endif
ifndef LOCAL_VENDOR_MODULE
  LOCAL_VENDOR_MODULE := $(LOCAL_PROPRIETARY_MODULE)
endif
ifneq ($(filter-out $(LOCAL_PROPRIETARY_MODULE),$(LOCAL_VENDOR_MODULE))$(filter-out $(LOCAL_VENDOR_MODULE),$(LOCAL_PROPRIETARY_MODULE)),)
$(call pretty-error,Only one of LOCAL_PROPRIETARY_MODULE[$(LOCAL_PROPRIETARY_MODULE)] and LOCAL_VENDOR_MODULE[$(LOCAL_VENDOR_MODULE)] may be set, or they must be equal)
endif

non_system_module := $(filter true, \
   $(LOCAL_PRODUCT_MODULE) \
   $(LOCAL_PRODUCT_SERVICES_MODULE) \
   $(LOCAL_VENDOR_MODULE) \
   $(LOCAL_PROPRIETARY_MODULE))

include $(BUILD_SYSTEM)/local_vndk.mk
include $(BUILD_SYSTEM)/local_systemsdk.mk

my_module_tags := $(LOCAL_MODULE_TAGS)
ifeq ($(my_host_cross),true)
  my_module_tags :=
endif
ifeq ($(TARGET_TRANSLATE_2ND_ARCH),true)
ifdef LOCAL_2ND_ARCH_VAR_PREFIX
# Don't pull in modules by tags if this is for translation TARGET_2ND_ARCH.
  my_module_tags :=
endif
endif

# Ninja has an implicit dependency on the command being run, and kati will
# regenerate the ninja manifest if any read makefile changes, so there is no
# need to have dependencies on makefiles.
# This won't catch all the cases where LOCAL_ADDITIONAL_DEPENDENCIES contains
# a .mk file, because a few users of LOCAL_ADDITIONAL_DEPENDENCIES don't include
# base_rules.mk, but it will fix the most common ones.
LOCAL_ADDITIONAL_DEPENDENCIES := $(filter-out %.mk,$(LOCAL_ADDITIONAL_DEPENDENCIES))

my_bad_deps := $(strip $(foreach dep,$(filter-out | ||,$(LOCAL_ADDITIONAL_DEPENDENCIES)),\
                 $(if $(findstring /,$(dep)),,$(dep))))
ifneq ($(my_bad_deps),)
$(call pretty-warning,"Bad LOCAL_ADDITIONAL_DEPENDENCIES: $(my_bad_deps)")
$(call pretty-error,"LOCAL_ADDITIONAL_DEPENDENCIES must only contain paths (not module names)")
=======
  my_prefix:=HOST_
  my_host:=host-
else
  my_prefix:=TARGET_
  my_host:=
>>>>>>> 1b0db93f (Merge pull request #122 from kanru/bug1031593)
endif

###########################################################
## Validate and define fallbacks for input LOCAL_* variables.
###########################################################

## Dump a .csv file of all modules and their tags
#ifneq ($(tag-list-first-time),false)
#$(shell rm -f tag-list.csv)
#tag-list-first-time := false
#endif
<<<<<<< HEAD
#$(shell echo $(lastword $(filter-out config/% out/%,$(MAKEFILE_LIST))),$(LOCAL_MODULE),$(strip $(LOCAL_MODULE_CLASS)),$(subst $(space),$(comma),$(sort $(my_module_tags))) >> tag-list.csv)

LOCAL_UNINSTALLABLE_MODULE := $(strip $(LOCAL_UNINSTALLABLE_MODULE))
my_module_tags := $(sort $(my_module_tags))
ifeq (,$(my_module_tags))
  my_module_tags := optional
endif

# User tags are not allowed anymore.  Fail early because it will not be installed
# like it used to be.
ifneq ($(filter $(my_module_tags),user),)
  $(warning *** Module name: $(LOCAL_MODULE))
  $(warning *** Makefile location: $(LOCAL_MODULE_MAKEFILE))
  $(warning * )
  $(warning * Module is attempting to use the 'user' tag.  This)
  $(warning * used to cause the module to be installed automatically.)
  $(warning * Now, the module must be listed in the PRODUCT_PACKAGES)
  $(warning * section of a product makefile to have it installed.)
  $(warning * )
  $(error user tag detected on module.)
endif

ifneq ($(filter $(DISABLED_USER_MODULES),$(LOCAL_MODULE)),)
LOCAL_MODULE_TAGS := optional
endif

my_bad_module_tags := $(filter eng debug,$(my_module_tags))
ifdef my_bad_module_tags
  ifeq (true,$(LOCAL_UNINSTALLABLE_MODULE))
    $(call pretty-warning,LOCAL_MODULE_TAGS := $(my_bad_module_tags) does not do anything for uninstallable modules)
  endif
  ifneq ($(BUILD_BROKEN_ENG_DEBUG_TAGS),true)
    $(call pretty-error,LOCAL_MODULE_TAGS := $(my_bad_module_tags) is obsolete. See $(CHANGES_URL)#LOCAL_MODULE_TAGS)
  else
    $(call pretty-warning,LOCAL_MODULE_TAGS := $(my_bad_module_tags) is deprecated. See $(CHANGES_URL)#LOCAL_MODULE_TAGS)
  endif
  my_bad_module_tags :=
=======
#comma := ,
#empty :=
#space := $(empty) $(empty)
#$(shell echo $(lastword $(filter-out config/% out/%,$(MAKEFILE_LIST))),$(LOCAL_MODULE),$(strip $(LOCAL_MODULE_CLASS)),$(subst $(space),$(comma),$(sort $(LOCAL_MODULE_TAGS))) >> tag-list.csv)

LOCAL_MODULE_TAGS := $(sort $(LOCAL_MODULE_TAGS))
ifeq (,$(LOCAL_MODULE_TAGS))
ifeq (true,$(LOCAL_UNINSTALLABLE_MODULE))
LOCAL_MODULE_TAGS := optional
else
# Installable modules without tags fall back to user (which is changed to user eng below)
LOCAL_MODULE_TAGS := user
endif
#$(warning default tags: $(lastword $(filter-out config/% out/%,$(MAKEFILE_LIST))))
>>>>>>> 1b0db93f (Merge pull request #122 from kanru/bug1031593)
endif

# Only the tags mentioned in this test are expected to be set by module
# makefiles. Anything else is either a typo or a source of unexpected
# behaviors.
<<<<<<< HEAD
ifneq ($(filter-out debug eng tests optional samples,$(my_module_tags)),)
$(call pretty-error,unusual tags: $(filter-out debug eng tests optional samples,$(my_module_tags)))
=======
ifneq ($(filter-out user debug eng tests optional samples shell_ash shell_mksh,$(LOCAL_MODULE_TAGS)),)
$(warning unusual tags $(LOCAL_MODULE_TAGS) on $(LOCAL_MODULE) at $(LOCAL_PATH))
endif

ifneq ($(filter $(OPTIONAL_USER_MODULES),$(LOCAL_MODULE)),)
LOCAL_MODULE_TAGS := optional
endif

ifneq ($(filter $(LOCAL_MODULE_TAGS),user),)
  ifeq ($(filter $(GRANDFATHERED_USER_MODULES),$(LOCAL_MODULE)),)
    $(warning *** Module name: $(LOCAL_MODULE))
    $(warning *** Makefile location: $(LOCAL_PATH))
    $(warning * )
    $(warning * Each module must use a LOCAL_MODULE_TAGS in its)
    $(warning * Android.mk. Possible tags declared by a module:)
    $(warning * )
    $(warning *     optional, debug, eng, tests, samples)
    $(warning * )
    $(warning * If the module is expected to be in all builds)
    $(warning * of a product, then it should use the)
    $(warning * "optional" tag: )
    $(warning * )
    $(warning *    Add "LOCAL_MODULE_TAGS := optional" in the)
    $(warning *    Android.mk for the affected module, and add)
    $(warning *    the LOCAL_MODULE value for that component)
    $(warning *    into the PRODUCT_PACKAGES section of product)
    $(warning *    makefile(s) where it's necessary, if)
    $(warning *    appropriate.)
    $(warning * )
    $(warning * If the component should be in EVERY build of ALL)
    $(warning * products, then add its LOCAL_MODULE value to the)
    $(warning * PRODUCT_PACKAGES section of)
    $(warning * build/target/product/core.mk)
    $(warning * )
    $(error user tag detected on new module - user tags are only supported on legacy modules)
  endif
>>>>>>> 1b0db93f (Merge pull request #122 from kanru/bug1031593)
endif

# Add implicit tags.
#
# If the local directory or one of its parents contains a MODULE_LICENSE_GPL
<<<<<<< HEAD
# file, tag the module as "gnu".  Search for "*_GPL*", "*_LGPL*" and "*_MPL*"
# so that we can also find files like MODULE_LICENSE_GPL_AND_AFL
#
license_files := $(call find-parent-file,$(LOCAL_PATH),MODULE_LICENSE*)
gpl_license_file := $(call find-parent-file,$(LOCAL_PATH),MODULE_LICENSE*_GPL* MODULE_LICENSE*_MPL* MODULE_LICENSE*_LGPL*)
ifneq ($(gpl_license_file),)
  my_module_tags += gnu
  ALL_GPL_MODULE_LICENSE_FILES := $(sort $(ALL_GPL_MODULE_LICENSE_FILES) $(gpl_license_file))
=======
# file, tag the module as "gnu".  Search for "*_GPL*" and "*_MPL*" so that we can also
# find files like MODULE_LICENSE_GPL_AND_AFL but exclude files like
# MODULE_LICENSE_LGPL.
#
ifneq ($(call find-parent-file,$(LOCAL_PATH),MODULE_LICENSE*_GPL* MODULE_LICENSE*_MPL*),)
  LOCAL_MODULE_TAGS += gnu
endif

#
# If this module is listed on CUSTOM_MODULES, promote it to "user"
# so that it will be installed in $(TARGET_OUT).
#
ifneq (,$(filter $(LOCAL_MODULE),$(CUSTOM_MODULES)))
  LOCAL_MODULE_TAGS := $(sort $(LOCAL_MODULE_TAGS) user)
endif

ifdef LOCAL_IS_HOST_MODULE
  partition_tag :=
else
ifeq (true,$(LOCAL_PROPRIETARY_MODULE))
  partition_tag := _VENDOR
else
  # The definition of should-install-to-system will be different depending
  # on which goal (e.g., sdk or just droid) is being built.
  partition_tag := $(if $(call should-install-to-system,$(LOCAL_MODULE_TAGS)),,_DATA)
endif
>>>>>>> 1b0db93f (Merge pull request #122 from kanru/bug1031593)
endif

LOCAL_MODULE_CLASS := $(strip $(LOCAL_MODULE_CLASS))
ifneq ($(words $(LOCAL_MODULE_CLASS)),1)
  $(error $(LOCAL_PATH): LOCAL_MODULE_CLASS must contain exactly one word, not "$(LOCAL_MODULE_CLASS)")
endif

<<<<<<< HEAD
my_32_64_bit_suffix := $(if $($(LOCAL_2ND_ARCH_VAR_PREFIX)$(my_prefix)IS_64_BIT),64,32)

ifneq (true,$(LOCAL_UNINSTALLABLE_MODULE))
ifeq ($(TARGET_TRANSLATE_2ND_ARCH),true)
# When in TARGET_TRANSLATE_2ND_ARCH both TARGET_ARCH and TARGET_2ND_ARCH are 32-bit,
# to avoid path conflict we force using LOCAL_MODULE_PATH_64 for the first arch.
ifdef LOCAL_2ND_ARCH_VAR_PREFIX
my_multilib_module_path := $(LOCAL_MODULE_PATH_32)
else  # ! LOCAL_2ND_ARCH_VAR_PREFIX
my_multilib_module_path := $(LOCAL_MODULE_PATH_64)
endif  # ! LOCAL_2ND_ARCH_VAR_PREFIX
else  # ! TARGET_TRANSLATE_2ND_ARCH
my_multilib_module_path := $(strip $(LOCAL_MODULE_PATH_$(my_32_64_bit_suffix)))
endif # ! TARGET_TRANSLATE_2ND_ARCH
ifdef my_multilib_module_path
my_module_path := $(my_multilib_module_path)
else
my_module_path := $(strip $(LOCAL_MODULE_PATH))
endif
my_module_path := $(patsubst %/,%,$(my_module_path))
my_module_relative_path := $(strip $(LOCAL_MODULE_RELATIVE_PATH))
ifdef LOCAL_IS_HOST_MODULE
  partition_tag :=
else
ifeq (true,$(strip $(LOCAL_VENDOR_MODULE)))
  partition_tag := _VENDOR
else ifeq (true,$(strip $(LOCAL_OEM_MODULE)))
  partition_tag := _OEM
else ifeq (true,$(strip $(LOCAL_ODM_MODULE)))
  partition_tag := _ODM
else ifeq (true,$(strip $(LOCAL_PRODUCT_MODULE)))
  partition_tag := _PRODUCT
else ifeq (true,$(strip $(LOCAL_PRODUCT_SERVICES_MODULE)))
  partition_tag := _PRODUCT_SERVICES
else ifeq (NATIVE_TESTS,$(LOCAL_MODULE_CLASS))
  partition_tag := _DATA
else
  # The definition of should-install-to-system will be different depending
  # on which goal (e.g., sdk or just droid) is being built.
  partition_tag := $(if $(call should-install-to-system,$(my_module_tags)),,_DATA)
endif
endif
# For test modules that lack a suite tag, set null-suite as the default.
# We only support adding a default suite to native tests, native benchmarks, and instrumentation tests.
# This is because they are the only tests we currently auto-generate test configs for.
ifndef LOCAL_COMPATIBILITY_SUITE
  ifneq ($(filter NATIVE_TESTS NATIVE_BENCHMARK, $(LOCAL_MODULE_CLASS)),)
    LOCAL_COMPATIBILITY_SUITE := null-suite
  endif
  ifneq ($(filter APPS, $(LOCAL_MODULE_CLASS)),)
    ifneq ($(filter $(my_module_tags),tests),)
      LOCAL_COMPATIBILITY_SUITE := null-suite
    endif
  endif
endif

use_testcase_folder :=
ifeq ($(my_module_path),)
  ifneq ($(LOCAL_MODULE),$(filter $(LOCAL_MODULE),$(DEFAULT_DATA_OUT_MODULES)))
    ifdef LOCAL_COMPATIBILITY_SUITE
      ifneq (true, $(LOCAL_IS_HOST_MODULE))
        use_testcase_folder := true
      endif
    endif
  endif
endif

ifeq ($(my_module_path),)
  install_path_var := $(LOCAL_2ND_ARCH_VAR_PREFIX)$(my_prefix)OUT$(partition_tag)_$(LOCAL_MODULE_CLASS)
  ifeq (true,$(LOCAL_PRIVILEGED_MODULE))
    install_path_var := $(install_path_var)_PRIVILEGED
  endif

  my_module_path := $($(install_path_var))

  # If use_testcase_folder be set, and LOCAL_MODULE_PATH not set,
  # overwrite the default path under testcase.
  ifeq ($(use_testcase_folder),true)
    arch_dir := $($(my_prefix)$(LOCAL_2ND_ARCH_VAR_PREFIX)ARCH)
    testcase_folder := $($(my_prefix)OUT_TESTCASES)/$(LOCAL_MODULE)/$(arch_dir)
    my_module_path := $(testcase_folder)
    arch_dir :=
  endif

  ifeq ($(strip $(my_module_path)),)
    $(error $(LOCAL_PATH): unhandled install path "$(install_path_var) for $(LOCAL_MODULE)")
  endif
endif
ifneq ($(my_module_relative_path),)
  my_module_path := $(my_module_path)/$(my_module_relative_path)
endif
endif # not LOCAL_UNINSTALLABLE_MODULE

=======
# Those used to be implicitly ignored, but aren't any more.
# As of 20100110 there are no apps with the user tag.
ifeq ($(LOCAL_MODULE_CLASS),APPS)
  ifneq ($(filter $(LOCAL_MODULE_TAGS),user),)
    $(warning user tag on app $(LOCAL_MODULE) at $(LOCAL_PATH) - add your app to core.mk instead)
  endif
endif

LOCAL_MODULE_PATH := $(strip $(LOCAL_MODULE_PATH))
ifeq ($(LOCAL_MODULE_PATH),)
  LOCAL_MODULE_PATH := $($(my_prefix)OUT$(partition_tag)_$(LOCAL_MODULE_CLASS))
  ifeq ($(strip $(LOCAL_MODULE_PATH)),)
    $(error $(LOCAL_PATH): unhandled LOCAL_MODULE_CLASS "$(LOCAL_MODULE_CLASS)")
  endif
endif

>>>>>>> 1b0db93f (Merge pull request #122 from kanru/bug1031593)
ifneq ($(strip $(LOCAL_BUILT_MODULE)$(LOCAL_INSTALLED_MODULE)),)
  $(error $(LOCAL_PATH): LOCAL_BUILT_MODULE and LOCAL_INSTALLED_MODULE must not be defined by component makefiles)
endif

<<<<<<< HEAD
my_register_name := $(LOCAL_MODULE)
ifeq ($(my_host_cross),true)
  my_register_name := host_cross_$(LOCAL_MODULE)
endif
ifdef LOCAL_2ND_ARCH_VAR_PREFIX
ifndef LOCAL_NO_2ND_ARCH_MODULE_SUFFIX
my_register_name := $(my_register_name)$($(my_prefix)2ND_ARCH_MODULE_SUFFIX)
endif
endif

ifeq ($(my_host_cross),true)
  my_all_targets := host_cross_$(my_register_name)_all_targets
else ifneq ($(LOCAL_IS_HOST_MODULE),)
  my_all_targets := host_$(my_register_name)_all_targets
else
  my_all_targets := device_$(my_register_name)_all_targets
endif

# variant is enough to make nano class unique; it serves as a key to lookup (OS,ARCH) tuple
aux_class := $($(my_prefix)OS_VARIANT)
# Make sure that this IS_HOST/CLASS/MODULE combination is unique.
module_id := MODULE.$(if \
    $(LOCAL_IS_HOST_MODULE),$($(my_prefix)OS),$(if \
    $(LOCAL_IS_AUX_MODULE),$(aux_class),TARGET)).$(LOCAL_MODULE_CLASS).$(my_register_name)
=======
# Make sure that this IS_HOST/CLASS/MODULE combination is unique.
module_id := MODULE.$(if \
    $(LOCAL_IS_HOST_MODULE),HOST,TARGET).$(LOCAL_MODULE_CLASS).$(LOCAL_MODULE)
>>>>>>> 1b0db93f (Merge pull request #122 from kanru/bug1031593)
ifdef $(module_id)
$(error $(LOCAL_PATH): $(module_id) already defined by $($(module_id)))
endif
$(module_id) := $(LOCAL_PATH)

<<<<<<< HEAD
intermediates := $(call local-intermediates-dir,,$(LOCAL_2ND_ARCH_VAR_PREFIX),$(my_host_cross))
intermediates.COMMON := $(call local-intermediates-dir,COMMON)
generated_sources_dir := $(call local-generated-sources-dir)

ifneq ($(LOCAL_OVERRIDES_MODULES),)
  ifndef LOCAL_IS_HOST_MODULE
    ifeq ($(LOCAL_MODULE_CLASS),EXECUTABLES)
      EXECUTABLES.$(LOCAL_MODULE).OVERRIDES := $(strip $(LOCAL_OVERRIDES_MODULES))
    else ifeq ($(LOCAL_MODULE_CLASS),SHARED_LIBRARIES)
      SHARED_LIBRARIES.$(LOCAL_MODULE).OVERRIDES := $(strip $(LOCAL_OVERRIDES_MODULES))
    else
      $(call pretty-error,LOCAL_MODULE_CLASS := $(LOCAL_MODULE_CLASS) cannot use LOCAL_OVERRIDES_MODULES)
    endif
  else
    $(call pretty-error,host modules cannot use LOCAL_OVERRIDES_MODULES)
  endif
endif
=======
intermediates := $(call local-intermediates-dir)
intermediates.COMMON := $(call local-intermediates-dir,COMMON)
>>>>>>> 1b0db93f (Merge pull request #122 from kanru/bug1031593)

###########################################################
# Pick a name for the intermediate and final targets
###########################################################
<<<<<<< HEAD
include $(BUILD_SYSTEM)/configure_module_stem.mk

LOCAL_BUILT_MODULE := $(intermediates)/$(my_built_module_stem)

ifneq (true,$(LOCAL_UNINSTALLABLE_MODULE))
  # Apk and its attachments reside in its own subdir.
  ifeq ($(LOCAL_MODULE_CLASS),APPS)
  # framework-res.apk doesn't like the additional layer.
  ifeq ($(LOCAL_NO_STANDARD_LIBRARIES),true)
  # Neither do Runtime Resource Overlay apks, which contain just the overlaid resources.
  else ifeq ($(LOCAL_IS_RUNTIME_RESOURCE_OVERLAY),true)
  else
    ifneq ($(use_testcase_folder),true)
      my_module_path := $(my_module_path)/$(LOCAL_MODULE)
    endif
  endif
  endif
  LOCAL_INSTALLED_MODULE := $(my_module_path)/$(my_installed_module_stem)
endif

ifneq ($(filter $(DISABLED_USER_MODULES),$(LOCAL_MODULE)),)
LOCAL_BUILT_MODULE :=
=======
LOCAL_MODULE_STEM := $(strip $(LOCAL_MODULE_STEM))
ifeq ($(LOCAL_MODULE_STEM),)
  LOCAL_MODULE_STEM := $(LOCAL_MODULE)
endif
LOCAL_INSTALLED_MODULE_STEM := $(LOCAL_MODULE_STEM)$(LOCAL_MODULE_SUFFIX)

LOCAL_BUILT_MODULE_STEM := $(strip $(LOCAL_BUILT_MODULE_STEM))
ifeq ($(LOCAL_BUILT_MODULE_STEM),)
  LOCAL_BUILT_MODULE_STEM := $(LOCAL_INSTALLED_MODULE_STEM)
endif

# OVERRIDE_BUILT_MODULE_PATH is only allowed to be used by the
# internal SHARED_LIBRARIES build files.
OVERRIDE_BUILT_MODULE_PATH := $(strip $(OVERRIDE_BUILT_MODULE_PATH))
ifdef OVERRIDE_BUILT_MODULE_PATH
  ifneq ($(LOCAL_MODULE_CLASS),SHARED_LIBRARIES)
    $(error $(LOCAL_PATH): Illegal use of OVERRIDE_BUILT_MODULE_PATH)
  endif
  built_module_path := $(OVERRIDE_BUILT_MODULE_PATH)
else
  built_module_path := $(intermediates)
endif
LOCAL_BUILT_MODULE := $(built_module_path)/$(LOCAL_BUILT_MODULE_STEM)
built_module_path :=

LOCAL_UNINSTALLABLE_MODULE := $(strip $(LOCAL_UNINSTALLABLE_MODULE))
ifneq (true,$(LOCAL_UNINSTALLABLE_MODULE))
  LOCAL_INSTALLED_MODULE := $(LOCAL_MODULE_PATH)/$(LOCAL_INSTALLED_MODULE_STEM)
>>>>>>> 1b0db93f (Merge pull request #122 from kanru/bug1031593)
endif

# Assemble the list of targets to create PRIVATE_ variables for.
LOCAL_INTERMEDIATE_TARGETS += $(LOCAL_BUILT_MODULE)

<<<<<<< HEAD
###########################################################
## Create .toc files from shared objects to reduce unnecessary rebuild
# .toc files have the list of external dynamic symbols without their addresses.
# As .KATI_RESTAT is specified to .toc files and commit-change-for-toc is used,
# dependent binaries of a .toc file will be rebuilt only when the content of
# the .toc file is changed.
#
# Don't create .toc files for Soong shared libraries, that is handled in
# Soong and soong_cc_prebuilt.mk
###########################################################
ifneq ($(LOCAL_MODULE_MAKEFILE),$(SOONG_ANDROID_MK))
ifeq ($(LOCAL_MODULE_CLASS),SHARED_LIBRARIES)
LOCAL_INTERMEDIATE_TARGETS += $(LOCAL_BUILT_MODULE).toc
$(LOCAL_BUILT_MODULE).toc: $(LOCAL_BUILT_MODULE)
	$(call $(PRIVATE_2ND_ARCH_VAR_PREFIX)$(PRIVATE_PREFIX)transform-shared-lib-to-toc,$<,$@.tmp)
	$(call commit-change-for-toc,$@)

# Kati adds restat=1 to ninja. GNU make does nothing for this.
.KATI_RESTAT: $(LOCAL_BUILT_MODULE).toc
# Build .toc file when using mm, mma, or make $(my_register_name)
$(my_all_targets): $(LOCAL_BUILT_MODULE).toc
endif
endif

###########################################################
## logtags: Add .logtags files to global list
###########################################################

logtags_sources := $(filter %.logtags,$(LOCAL_SRC_FILES)) $(LOCAL_LOGTAGS_FILES)

ifneq ($(strip $(logtags_sources)),)
event_log_tags := $(addprefix $(LOCAL_PATH)/,$(logtags_sources))
else
=======
ifneq ($(filter $(OPTIONAL_USER_MODULES),$(LOCAL_MODULE)),)
LOCAL_IMTERMEDIATE_TARGETS :=
LOCAL_BUILT_MODULE :=
endif


###########################################################
## AIDL: Compile .aidl files to .java
###########################################################

aidl_sources := $(filter %.aidl,$(LOCAL_SRC_FILES))

ifneq ($(strip $(aidl_sources)),)

aidl_java_sources := $(patsubst %.aidl,%.java,$(addprefix $(intermediates.COMMON)/src/, $(aidl_sources)))
aidl_sources := $(addprefix $(TOP_DIR)$(LOCAL_PATH)/, $(aidl_sources))

ifeq (,$(TARGET_BUILD_APPS))
LOCAL_AIDL_INCLUDES += $(FRAMEWORKS_BASE_JAVA_SRC_DIRS)
endif
aidl_preprocess_import :=
LOCAL_SDK_VERSION:=$(strip $(LOCAL_SDK_VERSION))
ifdef LOCAL_SDK_VERSION
ifeq ($(LOCAL_SDK_VERSION),current)
  aidl_preprocess_import := $(TARGET_OUT_COMMON_INTERMEDIATES)/framework.aidl
else
  aidl_preprocess_import := $(HISTORICAL_SDK_VERSIONS_ROOT)/$(LOCAL_SDK_VERSION)/framework.aidl
endif # !current
endif # LOCAL_SDK_VERSION
$(aidl_java_sources): PRIVATE_AIDL_FLAGS := -b $(addprefix -p,$(aidl_preprocess_import)) -I$(LOCAL_PATH) -I$(LOCAL_PATH)/src $(addprefix -I,$(LOCAL_AIDL_INCLUDES))

$(aidl_java_sources): $(intermediates.COMMON)/src/%.java: $(TOPDIR)$(LOCAL_PATH)/%.aidl $(LOCAL_ADDITIONAL_DEPENDENCIES) $(AIDL) $(aidl_preprocess_import)
	$(transform-aidl-to-java)
-include $(aidl_java_sources:%.java=%.P)

else
aidl_java_sources :=
endif

###########################################################
## logtags: Add .logtags files to global list, emit java source
###########################################################

logtags_sources := $(filter %.logtags,$(LOCAL_SRC_FILES))

ifneq ($(strip $(logtags_sources)),)

event_log_tags := $(addprefix $(LOCAL_PATH)/,$(logtags_sources))

# Emit a java source file with constants for the tags, if
# LOCAL_MODULE_CLASS is "APPS" or "JAVA_LIBRARIES".
ifneq ($(strip $(filter $(LOCAL_MODULE_CLASS),APPS JAVA_LIBRARIES)),)

logtags_java_sources := $(patsubst %.logtags,%.java,$(addprefix $(intermediates.COMMON)/src/, $(logtags_sources)))
logtags_sources := $(addprefix $(TOP_DIR)$(LOCAL_PATH)/, $(logtags_sources))

$(logtags_java_sources): $(intermediates.COMMON)/src/%.java: $(TOPDIR)$(LOCAL_PATH)/%.logtags $(TARGET_OUT_COMMON_INTERMEDIATES)/all-event-log-tags.txt
	$(transform-logtags-to-java)

endif

else
logtags_java_sources :=
>>>>>>> 1b0db93f (Merge pull request #122 from kanru/bug1031593)
event_log_tags :=
endif

###########################################################
<<<<<<< HEAD
## make clean- targets
###########################################################
cleantarget := clean-$(my_register_name)
.PHONY: $(cleantarget)
$(cleantarget) : PRIVATE_MODULE := $(my_register_name)
$(cleantarget) : PRIVATE_CLEAN_FILES := \
    $(LOCAL_BUILT_MODULE) \
    $(LOCAL_INSTALLED_MODULE) \
    $(intermediates)
=======
## .proto files: Compile proto files to .java
###########################################################
proto_sources := $(filter %.proto,$(LOCAL_SRC_FILES))
# Because names of the .java files compiled from .proto files are unknown until the
# .proto files are compiled, we use a timestamp file as depedency.
proto_java_sources_file_stamp :=
ifneq ($(proto_sources),)
proto_sources_fullpath := $(addprefix $(TOP_DIR)$(LOCAL_PATH)/, $(proto_sources))
# By putting the generated java files into $(LOCAL_INTERMEDIATE_SOURCE_DIR), they will be
# automatically found by the java compiling function transform-java-to-classes.jar.
ifneq ($(LOCAL_INTERMEDIATE_SOURCE_DIR),)
proto_java_intemediate_dir := $(LOCAL_INTERMEDIATE_SOURCE_DIR)/proto
else
# LOCAL_INTERMEDIATE_SOURCE_DIR may be not defined in non-java modules.
proto_java_intemediate_dir := $(intermediates)/proto
endif
proto_java_sources_file_stamp := $(proto_java_intemediate_dir)/Proto.stamp
proto_java_sources_dir := $(proto_java_intemediate_dir)/src

$(proto_java_sources_file_stamp): PRIVATE_PROTO_INCLUDES := $(TOP)
$(proto_java_sources_file_stamp): PRIVATE_PROTO_SRC_FILES := $(proto_sources_fullpath)
$(proto_java_sources_file_stamp): PRIVATE_PROTO_JAVA_OUTPUT_DIR := $(proto_java_sources_dir)
ifeq ($(LOCAL_PROTOC_OPTIMIZE_TYPE),micro)
$(proto_java_sources_file_stamp): PRIVATE_PROTO_JAVA_OUTPUT_OPTION := --javamicro_out
else
$(proto_java_sources_file_stamp): PRIVATE_PROTO_JAVA_OUTPUT_OPTION := --java_out
endif
$(proto_java_sources_file_stamp): PRIVATE_PROTOC_FLAGS := $(LOCAL_PROTOC_FLAGS)
$(proto_java_sources_file_stamp) : $(proto_sources_fullpath) $(PROTOC)
	$(call transform-proto-to-java)

#TODO: protoc should output the dependencies introduced by imports.

LOCAL_INTERMEDIATE_TARGETS += $(proto_java_sources_file_stamp)
endif # proto_sources


###########################################################
## Java: Compile .java files to .class
###########################################################
#TODO: pull this into java.make once host and target are combined

java_sources := $(addprefix $(TOP_DIR)$(LOCAL_PATH)/, $(filter %.java,$(LOCAL_SRC_FILES))) $(aidl_java_sources) $(logtags_java_sources) \
                $(filter %.java,$(LOCAL_GENERATED_SOURCES))
all_java_sources := $(java_sources) $(addprefix $($(my_prefix)OUT_COMMON_INTERMEDIATES)/, $(filter %.java,$(LOCAL_INTERMEDIATE_SOURCES)))

## Java resources #########################################

# Look for resource files in any specified directories.
# Non-java and non-doc files will be picked up as resources
# and included in the output jar file.
java_resource_file_groups :=

LOCAL_JAVA_RESOURCE_DIRS := $(strip $(LOCAL_JAVA_RESOURCE_DIRS))
ifneq ($(LOCAL_JAVA_RESOURCE_DIRS),)
  # This makes a list of words like
  #     <dir1>::<file1>:<file2> <dir2>::<file1> <dir3>:
  # where each of the files is relative to the directory it's grouped with.
  # Directories that don't contain any resource files will result in groups
  # that end with a colon, and they are stripped out in the next step.
  java_resource_file_groups += \
    $(foreach dir,$(LOCAL_JAVA_RESOURCE_DIRS), \
	$(subst $(space),:,$(strip \
		$(TOP_DIR)$(LOCAL_PATH)/$(dir): \
	    $(patsubst ./%,%,$(shell cd $(TOP_DIR)$(LOCAL_PATH)/$(dir) && \
		find . \
		    -type d -a -name ".svn" -prune -o \
		    -type f \
			-a \! -name "*.java" \
			-a \! -name "package.html" \
			-a \! -name "overview.html" \
			-a \! -name ".*.swp" \
			-a \! -name ".DS_Store" \
			-a \! -name "*~" \
			-print \
		    )) \
	)) \
    )
  java_resource_file_groups := $(filter-out %:,$(java_resource_file_groups))
endif # LOCAL_JAVA_RESOURCE_DIRS

LOCAL_JAVA_RESOURCE_FILES := $(strip $(LOCAL_JAVA_RESOURCE_FILES))
ifneq ($(LOCAL_JAVA_RESOURCE_FILES),)
  java_resource_file_groups += \
    $(foreach f,$(LOCAL_JAVA_RESOURCE_FILES), \
	$(patsubst %/,%,$(dir $(f)))::$(notdir $(f)) \
     )
endif # LOCAL_JAVA_RESOURCE_FILES

ifdef java_resource_file_groups
  # The full paths to all resources, used for dependencies.
  java_resource_sources := \
    $(foreach group,$(java_resource_file_groups), \
	$(addprefix $(word 1,$(subst :,$(space),$(group)))/, \
	    $(wordlist 2,9999,$(subst :,$(space),$(group))) \
	) \
    )
  # The arguments to jar that will include these files in a jar file.
  # Quote the file name to handle special characters (such as #) correctly.
  extra_jar_args := \
    $(foreach group,$(java_resource_file_groups), \
	$(addprefix -C "$(word 1,$(subst :,$(space),$(group)))" , \
	    $(foreach w, $(wordlist 2,9999,$(subst :,$(space),$(group))), "$(w)" ) \
	) \
    )
  java_resource_file_groups :=
else
  java_resource_sources :=
  extra_jar_args :=
endif # java_resource_file_groups

## PRIVATE java vars ######################################

ifneq ($(strip $(all_java_sources)$(all_res_assets)),)

full_static_java_libs := \
    $(foreach lib,$(LOCAL_STATIC_JAVA_LIBRARIES), \
      $(call intermediates-dir-for, \
        JAVA_LIBRARIES,$(lib),$(LOCAL_IS_HOST_MODULE),COMMON)/javalib.jar)

$(LOCAL_INTERMEDIATE_TARGETS): PRIVATE_INSTALL_DIR := $(dir $(LOCAL_INSTALLED_MODULE))
$(LOCAL_INTERMEDIATE_TARGETS): PRIVATE_CLASS_INTERMEDIATES_DIR := $(intermediates)/classes
$(LOCAL_INTERMEDIATE_TARGETS): PRIVATE_SOURCE_INTERMEDIATES_DIR := $(intermediates)/src
$(LOCAL_INTERMEDIATE_TARGETS): PRIVATE_JAVA_SOURCES := $(all_java_sources)
$(LOCAL_INTERMEDIATE_TARGETS): PRIVATE_JAVA_OBJECTS := $(patsubst %.java,%.class,$(LOCAL_SRC_FILES))
ifeq ($(my_prefix),TARGET_)
ifeq ($(LOCAL_SDK_VERSION),)
$(LOCAL_INTERMEDIATE_TARGETS): PRIVATE_BOOTCLASSPATH := -bootclasspath $(call java-lib-files,core)
else
ifeq ($(LOCAL_SDK_VERSION),current)
$(LOCAL_INTERMEDIATE_TARGETS): PRIVATE_BOOTCLASSPATH := -bootclasspath $(call java-lib-files,android_stubs_current)
else
$(LOCAL_INTERMEDIATE_TARGETS): PRIVATE_BOOTCLASSPATH := -bootclasspath $(call java-lib-files,sdk_v$(LOCAL_SDK_VERSION))
endif # current
endif # LOCAL_SDK_VERSION
endif # TARGET_
$(LOCAL_INTERMEDIATE_TARGETS): PRIVATE_RESOURCE_DIR := $(LOCAL_RESOURCE_DIR)
$(LOCAL_INTERMEDIATE_TARGETS): PRIVATE_EXTRA_JAR_ARGS := $(extra_jar_args)
$(LOCAL_INTERMEDIATE_TARGETS): PRIVATE_ASSET_DIR := $(LOCAL_ASSET_DIR)
$(LOCAL_INTERMEDIATE_TARGETS): PRIVATE_STATIC_JAVA_LIBRARIES := $(full_static_java_libs)

# full_java_libs: The list of files that should be used as the classpath.
#                 Using this list as a dependency list WILL NOT WORK.
# full_java_lib_deps: Should be specified as a prerequisite of this module
#                 to guarantee that the files in full_java_libs will
#                 be up-to-date.
ifdef LOCAL_IS_HOST_MODULE
ifeq ($(LOCAL_BUILD_HOST_DEX),true)
$(LOCAL_INTERMEDIATE_TARGETS): PRIVATE_BOOTCLASSPATH := -bootclasspath $(call java-lib-files,core-hostdex,$(LOCAL_IS_HOST_MODULE))

full_java_libs := $(call java-lib-files,$(LOCAL_JAVA_LIBRARIES),$(LOCAL_IS_HOST_MODULE))
full_java_lib_deps := $(call java-lib-deps,$(LOCAL_JAVA_LIBRARIES),$(LOCAL_IS_HOST_MODULE))
else
$(LOCAL_INTERMEDIATE_TARGETS): PRIVATE_BOOTCLASSPATH :=

full_java_libs := $(addprefix $(HOST_OUT_JAVA_LIBRARIES)/,$(addsuffix $(COMMON_JAVA_PACKAGE_SUFFIX),$(LOCAL_JAVA_LIBRARIES)))
full_java_lib_deps := $(full_java_libs)
endif # LOCAL_BUILD_HOST_DEX
else
full_java_libs := $(call java-lib-files,$(LOCAL_JAVA_LIBRARIES),$(LOCAL_IS_HOST_MODULE))
full_java_lib_deps := $(call java-lib-deps,$(LOCAL_JAVA_LIBRARIES),$(LOCAL_IS_HOST_MODULE))
endif # !LOCAL_IS_HOST_MODULE
full_java_libs += $(full_static_java_libs) $(LOCAL_CLASSPATH)
full_java_lib_deps += $(full_static_java_libs) $(LOCAL_CLASSPATH)

# This is set by packages that contain instrumentation, allowing them to
# link against the package they are instrumenting.  Currently only one such
# package is allowed.
LOCAL_INSTRUMENTATION_FOR := $(strip $(LOCAL_INSTRUMENTATION_FOR))
ifdef LOCAL_INSTRUMENTATION_FOR
  ifneq ($(words $(LOCAL_INSTRUMENTATION_FOR)),1)
    $(error \
        $(LOCAL_PATH): Multiple LOCAL_INSTRUMENTATION_FOR members defined)
  endif

  link_instr_intermediates_dir := $(call intermediates-dir-for, \
      APPS,$(LOCAL_INSTRUMENTATION_FOR))
  link_instr_intermediates_dir.COMMON := $(call intermediates-dir-for, \
      APPS,$(LOCAL_INSTRUMENTATION_FOR),,COMMON)

  # link against the jar with full original names (before proguard processing).
  full_java_libs += $(link_instr_intermediates_dir.COMMON)/classes.jar
  full_java_lib_deps += $(link_instr_intermediates_dir.COMMON)/classes.jar
endif

jar_manifest_file :=
ifneq ($(strip $(LOCAL_JAR_MANIFEST)),)
jar_manifest_file := $(LOCAL_PATH)/$(LOCAL_JAR_MANIFEST)
$(LOCAL_INTERMEDIATE_TARGETS): PRIVATE_JAR_MANIFEST := $(jar_manifest_file)
else
$(LOCAL_INTERMEDIATE_TARGETS): PRIVATE_JAR_MANIFEST :=
endif

endif


###########################################################
## make clean- targets
###########################################################
cleantarget := clean-$(LOCAL_MODULE)
$(cleantarget) : PRIVATE_MODULE := $(LOCAL_MODULE)
$(cleantarget) : PRIVATE_CLEAN_FILES := \
		$(PRIVATE_CLEAN_FILES) \
		$(LOCAL_BUILT_MODULE) \
		$(LOCAL_INSTALLED_MODULE) \
		$(intermediates)
>>>>>>> 1b0db93f (Merge pull request #122 from kanru/bug1031593)
$(cleantarget)::
	@echo "Clean: $(PRIVATE_MODULE)"
	$(hide) rm -rf $(PRIVATE_CLEAN_FILES)

###########################################################
## Common definitions for module.
###########################################################
<<<<<<< HEAD
$(LOCAL_INTERMEDIATE_TARGETS) : PRIVATE_PATH:=$(LOCAL_PATH)
$(LOCAL_INTERMEDIATE_TARGETS) : PRIVATE_IS_HOST_MODULE := $(LOCAL_IS_HOST_MODULE)
$(LOCAL_INTERMEDIATE_TARGETS) : PRIVATE_IS_AUX_MODULE := $(LOCAL_IS_AUX_MODULE)
$(LOCAL_INTERMEDIATE_TARGETS) : PRIVATE_HOST:= $(my_host)
$(LOCAL_INTERMEDIATE_TARGETS) : PRIVATE_PREFIX := $(my_prefix)

$(LOCAL_INTERMEDIATE_TARGETS) : PRIVATE_INTERMEDIATES_DIR:= $(intermediates)
$(LOCAL_INTERMEDIATE_TARGETS) : PRIVATE_2ND_ARCH_VAR_PREFIX := $(LOCAL_2ND_ARCH_VAR_PREFIX)

# Tell the module and all of its sub-modules who it is.
$(LOCAL_INTERMEDIATE_TARGETS) : PRIVATE_MODULE:= $(my_register_name)
=======

# Propagate local configuration options to this target.
$(LOCAL_INTERMEDIATE_TARGETS) : PRIVATE_PATH:=$(LOCAL_PATH)
$(LOCAL_INTERMEDIATE_TARGETS) : PRIVATE_POST_PROCESS_COMMAND:= $(LOCAL_POST_PROCESS_COMMAND)
$(LOCAL_INTERMEDIATE_TARGETS) : PRIVATE_AAPT_FLAGS:= $(LOCAL_AAPT_FLAGS)
$(LOCAL_INTERMEDIATE_TARGETS) : PRIVATE_JAVA_LIBRARIES:= $(LOCAL_JAVA_LIBRARIES)
$(LOCAL_INTERMEDIATE_TARGETS) : PRIVATE_MANIFEST_PACKAGE_NAME:= $(LOCAL_MANIFEST_PACKAGE_NAME)
$(LOCAL_INTERMEDIATE_TARGETS) : PRIVATE_MANIFEST_INSTRUMENTATION_FOR:= $(LOCAL_MANIFEST_INSTRUMENTATION_FOR)

$(LOCAL_INTERMEDIATE_TARGETS) : PRIVATE_ALL_JAVA_LIBRARIES:= $(full_java_libs)
$(LOCAL_INTERMEDIATE_TARGETS) : PRIVATE_IS_HOST_MODULE := $(LOCAL_IS_HOST_MODULE)
$(LOCAL_INTERMEDIATE_TARGETS) : PRIVATE_HOST:= $(my_host)

$(LOCAL_INTERMEDIATE_TARGETS) : PRIVATE_INTERMEDIATES_DIR:= $(intermediates)

# Tell the module and all of its sub-modules who it is.
$(LOCAL_INTERMEDIATE_TARGETS) : PRIVATE_MODULE:= $(LOCAL_MODULE)
>>>>>>> 1b0db93f (Merge pull request #122 from kanru/bug1031593)

# Provide a short-hand for building this module.
# We name both BUILT and INSTALLED in case
# LOCAL_UNINSTALLABLE_MODULE is set.
<<<<<<< HEAD
.PHONY: $(my_all_targets)
$(my_all_targets): $(LOCAL_BUILT_MODULE) $(LOCAL_INSTALLED_MODULE) $(LOCAL_ADDITIONAL_CHECKED_MODULE)

.PHONY: $(my_register_name)
$(my_register_name): $(my_all_targets)

ifneq ($(my_register_name),$(LOCAL_MODULE))
# $(LOCAL_MODULE) covers all the multilib targets.
.PHONY: $(LOCAL_MODULE)
$(LOCAL_MODULE) : $(my_all_targets)
endif

# Set up phony targets that covers all modules under the given paths.
# This allows us to build everything in given paths by running mmma/mma.
my_path_components := $(subst /,$(space),$(LOCAL_PATH))
my_path_prefix := MODULES-IN
$(foreach c, $(my_path_components),\
  $(eval my_path_prefix := $(my_path_prefix)-$(c))\
  $(eval .PHONY : $(my_path_prefix))\
  $(eval $(my_path_prefix) : $(my_all_targets)))
=======
.PHONY: $(LOCAL_MODULE)
$(LOCAL_MODULE): $(LOCAL_BUILT_MODULE) $(LOCAL_INSTALLED_MODULE)
>>>>>>> 1b0db93f (Merge pull request #122 from kanru/bug1031593)

###########################################################
## Module installation rule
###########################################################

<<<<<<< HEAD
ifneq ($(filter $(DISABLED_USER_MODULES),$(LOCAL_MODULE)),)
LOCAL_UNINSTALLABLE_MODULE := true
endif

my_init_rc_installed :=
my_init_rc_pairs :=
my_installed_symlinks :=
my_default_test_module :=
ifeq ($(use_testcase_folder),true)
arch_dir := $($(my_prefix)$(LOCAL_2ND_ARCH_VAR_PREFIX)ARCH)
my_default_test_module := $($(my_prefix)OUT_TESTCASES)/$(LOCAL_MODULE)/$(arch_dir)/$(my_installed_module_stem)
arch_dir :=
endif

ifneq (true,$(LOCAL_UNINSTALLABLE_MODULE))
ifneq ($(LOCAL_INSTALLED_MODULE),$(my_default_test_module))
$(LOCAL_INSTALLED_MODULE): PRIVATE_POST_INSTALL_CMD := $(LOCAL_POST_INSTALL_CMD)
$(LOCAL_INSTALLED_MODULE): $(LOCAL_BUILT_MODULE)
	@echo "Install: $@"
	$(copy-file-to-new-target)
	$(PRIVATE_POST_INSTALL_CMD)
endif

ifndef LOCAL_IS_HOST_MODULE
# Rule to install the module's companion init.rc.
my_init_rc := $(LOCAL_INIT_RC_$(my_32_64_bit_suffix)) $(LOCAL_INIT_RC)
ifneq ($(strip $(my_init_rc)),)
my_init_rc_pairs := $(foreach rc,$(my_init_rc),$(LOCAL_PATH)/$(rc):$(TARGET_OUT$(partition_tag)_ETC)/init/$(notdir $(rc)))
my_init_rc_installed := $(foreach rc,$(my_init_rc_pairs),$(call word-colon,2,$(rc)))

# Make sure we only set up the copy rules once, even if another arch variant
# shares a common LOCAL_INIT_RC.
my_init_rc_new_pairs := $(filter-out $(ALL_INIT_RC_INSTALLED_PAIRS),$(my_init_rc_pairs))
my_init_rc_new_installed := $(call copy-many-init-script-files-checked,$(my_init_rc_new_pairs))
ALL_INIT_RC_INSTALLED_PAIRS += $(my_init_rc_new_pairs)

$(my_all_targets) : $(my_init_rc_installed)
endif # my_init_rc
endif # !LOCAL_IS_HOST_MODULE

# Rule to install the module's companion symlinks
my_installed_symlinks := $(addprefix $(my_module_path)/,$(LOCAL_MODULE_SYMLINKS) $(LOCAL_MODULE_SYMLINKS_$(my_32_64_bit_suffix)))
$(foreach symlink,$(my_installed_symlinks),\
    $(call symlink-file,$(LOCAL_INSTALLED_MODULE),$(my_installed_module_stem),$(symlink)))

$(my_all_targets) : | $(my_installed_symlinks)

endif # !LOCAL_UNINSTALLABLE_MODULE

###########################################################
## VINTF manifest fragment goals
###########################################################

my_vintf_installed:=
my_vintf_pairs:=
ifneq (true,$(LOCAL_UNINSTALLABLE_MODULE))
ifndef LOCAL_IS_HOST_MODULE
ifneq ($(strip $(LOCAL_VINTF_FRAGMENTS)),)

my_vintf_pairs := $(foreach xml,$(LOCAL_VINTF_FRAGMENTS),$(LOCAL_PATH)/$(xml):$(TARGET_OUT$(partition_tag)_ETC)/vintf/manifest/$(notdir $(xml)))
my_vintf_installed := $(foreach xml,$(my_vintf_pairs),$(call word-colon,2,$(xml)))

# Only set up copy rules once, even if another arch variant shares it
my_vintf_new_pairs := $(filter-out $(ALL_VINTF_MANIFEST_FRAGMENTS_LIST),$(my_vintf_pairs))
my_vintf_new_installed := $(call copy-many-vintf-manifest-files-checked,$(my_vintf_pairs))

ALL_VINTF_MANIFEST_FRAGMENTS_LIST += $(my_vintf_new_pairs)

$(my_all_targets) : $(my_vintf_installed)
endif # LOCAL_VINTF_FRAGMENTS
endif # !LOCAL_IS_HOST_MODULE
endif # !LOCAL_UNINSTALLABLE_MODULE
=======
# Some hosts do not have ACP; override the LOCAL version if that's the case.
ifneq ($(strip $(HOST_ACP_UNAVAILABLE)),)
  LOCAL_ACP_UNAVAILABLE := $(strip $(HOST_ACP_UNAVAILABLE))
endif

ifndef LOCAL_UNINSTALLABLE_MODULE
  # Define a copy rule to install the module.
  # acp and libraries that it uses can't use acp for
  # installation;  hence, LOCAL_ACP_UNAVAILABLE.
ifneq ($(LOCAL_ACP_UNAVAILABLE),true)
$(LOCAL_INSTALLED_MODULE): $(LOCAL_BUILT_MODULE) | $(ACP)
	@echo "Install: $@"
	$(copy-file-to-new-target)
else
$(LOCAL_INSTALLED_MODULE): $(LOCAL_BUILT_MODULE)
	@echo "Install: $@"
	$(copy-file-to-target-with-cp)
endif

ifdef LOCAL_DEX_PREOPT
installed_odex := $(basename $(LOCAL_INSTALLED_MODULE)).odex
built_odex := $(basename $(LOCAL_BUILT_MODULE)).odex
$(installed_odex) : $(built_odex) | $(ACP)
	@echo "Install: $@"
	$(copy-file-to-target)

$(LOCAL_INSTALLED_MODULE) : $(installed_odex)
endif

endif # !LOCAL_UNINSTALLABLE_MODULE

>>>>>>> 1b0db93f (Merge pull request #122 from kanru/bug1031593)

###########################################################
## CHECK_BUILD goals
###########################################################
<<<<<<< HEAD
my_checked_module :=
# If nobody has defined a more specific module for the
# checked modules, use LOCAL_BUILT_MODULE.
ifdef LOCAL_CHECKED_MODULE
  my_checked_module := $(LOCAL_CHECKED_MODULE)
else
  my_checked_module := $(LOCAL_BUILT_MODULE)
endif

my_checked_module += $(LOCAL_ADDITIONAL_CHECKED_MODULE)
=======

# If nobody has defined a more specific module for the
# checked modules, use LOCAL_BUILT_MODULE.  This was old
# behavior, so it should be a safe default.
ifndef LOCAL_CHECKED_MODULE
  ifndef LOCAL_SDK_VERSION
    LOCAL_CHECKED_MODULE := $(LOCAL_BUILT_MODULE)
  endif
endif
>>>>>>> 1b0db93f (Merge pull request #122 from kanru/bug1031593)

# If they request that this module not be checked, then don't.
# PLEASE DON'T SET THIS.  ANY PLACES THAT SET THIS WITHOUT
# GOOD REASON WILL HAVE IT REMOVED.
ifdef LOCAL_DONT_CHECK_MODULE
<<<<<<< HEAD
  my_checked_module :=
endif
# Don't check build target module defined for the 2nd arch
ifndef LOCAL_IS_HOST_MODULE
ifdef LOCAL_2ND_ARCH_VAR_PREFIX
  my_checked_module :=
endif
endif

###########################################################
## Test Data
###########################################################
my_test_data_pairs :=
my_installed_test_data :=
# Source to relative dst file paths for reuse in LOCAL_COMPATIBILITY_SUITE.
my_test_data_file_pairs :=

ifneq ($(filter NATIVE_TESTS,$(LOCAL_MODULE_CLASS)),)
ifneq ($(strip $(LOCAL_TEST_DATA)),)
ifneq (true,$(LOCAL_UNINSTALLABLE_MODULE))

my_test_data_pairs := $(strip $(foreach td,$(LOCAL_TEST_DATA), \
    $(eval _file := $(call word-colon,2,$(td))) \
    $(if $(_file), \
      $(eval _src_base := $(call word-colon,1,$(td))), \
      $(eval _src_base := $(LOCAL_PATH)) \
        $(eval _file := $(call word-colon,1,$(td)))) \
    $(if $(call streq,$(LOCAL_MODULE_MAKEFILE),$(SOONG_ANDROID_MK)),, \
      $(if $(findstring ..,$(_file)),$(error $(LOCAL_MODULE_MAKEFILE): LOCAL_TEST_DATA may not include '..': $(_file))) \
      $(if $(filter /%,$(_src_base) $(_file)),$(error $(LOCAL_MODULE_MAKEFILE): LOCAL_TEST_DATA may not include absolute paths: $(_src_base) $(_file)))) \
    $(eval my_test_data_file_pairs := $(my_test_data_file_pairs) $(call append-path,$(_src_base),$(_file)):$(_file)) \
    $(call append-path,$(_src_base),$(_file)):$(call append-path,$(my_module_path),$(_file))))

my_installed_test_data := $(call copy-many-files,$(my_test_data_pairs))
$(LOCAL_INSTALLED_MODULE): $(my_installed_test_data)

endif
endif
endif

###########################################################
## Compatibility suite files.
###########################################################
ifdef LOCAL_COMPATIBILITY_SUITE

# If we are building a native test or benchmark and its stem variants are not defined,
# separate the multiple architectures into subdirectories of the testcase folder.
arch_dir :=
is_native :=
multi_arch :=
ifeq ($(LOCAL_MODULE_CLASS),NATIVE_TESTS)
  is_native := true
  multi_arch := true
endif
ifdef LOCAL_MULTILIB
  multi_arch := true
endif

ifdef multi_arch
arch_dir := /$($(my_prefix)$(LOCAL_2ND_ARCH_VAR_PREFIX)ARCH)
else
ifeq ($(use_testcase_folder),true)
  arch_dir := /$($(my_prefix)$(LOCAL_2ND_ARCH_VAR_PREFIX)ARCH)
endif
endif

multi_arch :=

my_default_test_module :=
my_default_test_module := $($(my_prefix)OUT_TESTCASES)/$(LOCAL_MODULE)$(arch_dir)/$(my_installed_module_stem)
ifneq ($(LOCAL_INSTALLED_MODULE),$(my_default_test_module))
# Install into the testcase folder
$(LOCAL_INSTALLED_MODULE) : $(my_default_test_module)
endif

# The module itself.
$(foreach suite, $(LOCAL_COMPATIBILITY_SUITE), \
  $(eval my_compat_dist_$(suite) := $(foreach dir, $(call compatibility_suite_dirs,$(suite),$(arch_dir)), \
    $(LOCAL_BUILT_MODULE):$(dir)/$(my_installed_module_stem))) \
  $(eval my_compat_dist_config_$(suite) := ))


# Auto-generate build config.
ifneq (,$(LOCAL_FULL_TEST_CONFIG))
  test_config := $(LOCAL_FULL_TEST_CONFIG)
else ifneq (,$(LOCAL_TEST_CONFIG))
  test_config := $(LOCAL_PATH)/$(LOCAL_TEST_CONFIG)
else
  test_config := $(wildcard $(LOCAL_PATH)/AndroidTest.xml)
endif
ifeq (,$(test_config))
  ifneq (true,$(is_native))
    is_instrumentation_test := true
    ifeq (true, $(LOCAL_IS_HOST_MODULE))
      is_instrumentation_test := false
    endif
    # If LOCAL_MODULE_CLASS is not APPS, it's certainly not an instrumentation
    # test. However, some packages for test data also have LOCAL_MODULE_CLASS
    # set to APPS. These will require flag LOCAL_DISABLE_AUTO_GENERATE_TEST_CONFIG
    # to disable auto-generating test config file.
    ifneq (APPS, $(LOCAL_MODULE_CLASS))
      is_instrumentation_test := false
    endif
  endif
  # CTS modules can be used for test data, so test config files must be
  # explicitly created using AndroidTest.xml
  ifeq (,$(filter cts, $(LOCAL_COMPATIBILITY_SUITE)))
    ifneq (true, $(LOCAL_DISABLE_AUTO_GENERATE_TEST_CONFIG))
      ifeq (true, $(filter true,$(is_native) $(is_instrumentation_test)))
        include $(BUILD_SYSTEM)/autogen_test_config.mk
        test_config := $(autogen_test_config_file)
        autogen_test_config_file :=
      endif
    endif
  endif
endif
is_instrumentation_test :=

# Make sure we only add the files once for multilib modules.
ifdef $(my_prefix)$(LOCAL_MODULE_CLASS)_$(LOCAL_MODULE)_compat_files
  # Sync the auto_test_config value for multilib modules.
  ifdef $(my_prefix)$(LOCAL_MODULE_CLASS)_$(LOCAL_MODULE)_autogen
    ALL_MODULES.$(my_register_name).auto_test_config := true
  endif
else
  $(my_prefix)$(LOCAL_MODULE_CLASS)_$(LOCAL_MODULE)_compat_files := true
  # LOCAL_COMPATIBILITY_SUPPORT_FILES is a list of <src>[:<dest>].
  $(foreach suite, $(LOCAL_COMPATIBILITY_SUITE), \
    $(eval my_compat_dist_$(suite) += $(foreach f, $(LOCAL_COMPATIBILITY_SUPPORT_FILES), \
      $(eval p := $(subst :,$(space),$(f))) \
      $(eval s := $(word 1,$(p))) \
      $(eval n := $(or $(word 2,$(p)),$(notdir $(word 1, $(p))))) \
      $(foreach dir, $(call compatibility_suite_dirs,$(suite)), \
        $(s):$(dir)/$(n)))))

  ifneq (,$(test_config))
    $(foreach suite, $(LOCAL_COMPATIBILITY_SUITE), \
      $(eval my_compat_dist_config_$(suite) += $(foreach dir, $(call compatibility_suite_dirs,$(suite)), \
        $(test_config):$(dir)/$(LOCAL_MODULE).config)))
  endif

  ifneq (,$(wildcard $(LOCAL_PATH)/DynamicConfig.xml))
    $(foreach suite, $(LOCAL_COMPATIBILITY_SUITE), \
      $(eval my_compat_dist_config_$(suite) += $(foreach dir, $(call compatibility_suite_dirs,$(suite)), \
        $(LOCAL_PATH)/DynamicConfig.xml:$(dir)/$(LOCAL_MODULE).dynamic)))
  endif

  ifneq (,$(wildcard $(LOCAL_PATH)/$(LOCAL_MODULE)_*.config))
  $(foreach extra_config, $(wildcard $(LOCAL_PATH)/$(LOCAL_MODULE)_*.config), \
    $(foreach suite, $(LOCAL_COMPATIBILITY_SUITE), \
      $(eval my_compat_dist_config_$(suite) += $(foreach dir, $(call compatibility_suite_dirs,$(suite)), \
        $(extra_config):$(dir)/$(notdir $(extra_config))))))
  endif
endif # $(my_prefix)$(LOCAL_MODULE_CLASS)_$(LOCAL_MODULE)_compat_files

# HACK: pretend a soong LOCAL_FULL_TEST_CONFIG is autogenerated by setting the flag in
# module-info.json
# TODO: (b/113029686) Add explicit flag from Soong to determine if a test was
# autogenerated.
ifneq (,$(filter $(SOONG_OUT_DIR)%,$(LOCAL_FULL_TEST_CONFIG)))
  ifeq ($(LOCAL_MODULE_MAKEFILE),$(SOONG_ANDROID_MK))
    ALL_MODULES.$(my_register_name).auto_test_config := true
  endif
endif


ifeq ($(use_testcase_folder),true)
ifneq ($(my_test_data_file_pairs),)
$(foreach pair, $(my_test_data_file_pairs), \
  $(eval parts := $(subst :,$(space),$(pair))) \
  $(eval src_path := $(word 1,$(parts))) \
  $(eval file := $(word 2,$(parts))) \
  $(foreach suite, $(LOCAL_COMPATIBILITY_SUITE), \
    $(eval my_compat_dist_$(suite) += $(foreach dir, $(call compatibility_suite_dirs,$(suite),$(arch_dir)), \
      $(call filter-copy-pair,$(src_path),$(call append-path,$(dir),$(file)),$(my_installed_test_data))))))
endif
else
ifneq ($(my_test_data_file_pairs),)
$(foreach pair, $(my_test_data_file_pairs), \
  $(eval parts := $(subst :,$(space),$(pair))) \
  $(eval src_path := $(word 1,$(parts))) \
  $(eval file := $(word 2,$(parts))) \
  $(foreach suite, $(LOCAL_COMPATIBILITY_SUITE), \
    $(eval my_compat_dist_$(suite) += $(foreach dir, $(call compatibility_suite_dirs,$(suite),$(arch_dir)), \
      $(src_path):$(call append-path,$(dir),$(file))))))
endif
endif



arch_dir :=
is_native :=

$(call create-suite-dependencies)
$(foreach suite, $(LOCAL_COMPATIBILITY_SUITE), \
  $(eval my_compat_dist_config_$(suite) := ))

endif  # LOCAL_COMPATIBILITY_SUITE

###########################################################
## Add test module to ALL_DISABLED_PRESUBMIT_TESTS if LOCAL_PRESUBMIT_DISABLED is set to true.
###########################################################
ifeq ($(LOCAL_PRESUBMIT_DISABLED),true)
  ALL_DISABLED_PRESUBMIT_TESTS += $(LOCAL_MODULE)
endif  # LOCAL_PRESUBMIT_DISABLED
=======
  LOCAL_CHECKED_MODULE :=
endif
>>>>>>> 1b0db93f (Merge pull request #122 from kanru/bug1031593)

###########################################################
## Register with ALL_MODULES
###########################################################

<<<<<<< HEAD
ifeq ($(filter $(my_register_name),$(ALL_MODULES)),)
    # These keys are no longer used, they've been replaced by keys that specify
    # target/host/host_cross (REQUIRED_FROM_TARGET / REQUIRED_FROM_HOST) and similar.
    #
    # Marking them obsolete to ensure that anyone using these internal variables looks for
    # alternates.
    $(KATI_obsolete_var ALL_MODULES.$(my_register_name).REQUIRED)
    $(KATI_obsolete_var ALL_MODULES.$(my_register_name).EXPLICITLY_REQUIRED)
    $(KATI_obsolete_var ALL_MODULES.$(my_register_name).HOST_REQUIRED)
    $(KATI_obsolete_var ALL_MODULES.$(my_register_name).TARGET_REQUIRED)
endif

ALL_MODULES += $(my_register_name)

# Don't use += on subvars, or else they'll end up being
# recursively expanded.
ALL_MODULES.$(my_register_name).CLASS := \
    $(ALL_MODULES.$(my_register_name).CLASS) $(LOCAL_MODULE_CLASS)
ALL_MODULES.$(my_register_name).PATH := \
    $(ALL_MODULES.$(my_register_name).PATH) $(LOCAL_PATH)
ALL_MODULES.$(my_register_name).TAGS := \
    $(ALL_MODULES.$(my_register_name).TAGS) $(my_module_tags)
ALL_MODULES.$(my_register_name).CHECKED := \
    $(ALL_MODULES.$(my_register_name).CHECKED) $(my_checked_module)
ALL_MODULES.$(my_register_name).BUILT := \
    $(ALL_MODULES.$(my_register_name).BUILT) $(LOCAL_BUILT_MODULE)
ifndef LOCAL_IS_HOST_MODULE
ALL_MODULES.$(my_register_name).TARGET_BUILT := \
    $(ALL_MODULES.$(my_register_name).TARGET_BUILT) $(LOCAL_BUILT_MODULE)
endif
ifneq (true,$(LOCAL_UNINSTALLABLE_MODULE))
ALL_MODULES.$(my_register_name).INSTALLED := \
    $(strip $(ALL_MODULES.$(my_register_name).INSTALLED) \
    $(LOCAL_INSTALLED_MODULE) $(my_init_rc_installed) $(my_installed_symlinks) \
    $(my_installed_test_data) $(my_vintf_installed))
ALL_MODULES.$(my_register_name).BUILT_INSTALLED := \
    $(strip $(ALL_MODULES.$(my_register_name).BUILT_INSTALLED) \
    $(LOCAL_BUILT_MODULE):$(LOCAL_INSTALLED_MODULE) \
    $(my_init_rc_pairs) $(my_test_data_pairs) $(my_vintf_pairs))
endif
ifdef LOCAL_PICKUP_FILES
# Files or directories ready to pick up by the build system
# when $(LOCAL_BUILT_MODULE) is done.
ALL_MODULES.$(my_register_name).PICKUP_FILES := \
    $(ALL_MODULES.$(my_register_name).PICKUP_FILES) $(LOCAL_PICKUP_FILES)
endif

my_required_modules := $(LOCAL_REQUIRED_MODULES) \
    $(LOCAL_REQUIRED_MODULES_$(TARGET_$(LOCAL_2ND_ARCH_VAR_PREFIX)ARCH))
ifdef LOCAL_IS_HOST_MODULE
my_required_modules += $(LOCAL_REQUIRED_MODULES_$($(my_prefix)OS))
endif

###############################################################################
## When compiling against the VNDK, add the .vendor suffix to required modules.
###############################################################################
ifneq ($(LOCAL_USE_VNDK),)
  ####################################################
  ## Soong modules may be built twice, once for /system
  ## and once for /vendor. If we're using the VNDK,
  ## switch all soong libraries over to the /vendor
  ## variant.
  ####################################################
  ifneq ($(LOCAL_MODULE_MAKEFILE),$(SOONG_ANDROID_MK))
    # We don't do this renaming for soong-defined modules since they already
    # have correct names (with .vendor suffix when necessary) in their
    # LOCAL_*_LIBRARIES.
    my_required_modules := $(foreach l,$(my_required_modules),\
      $(if $(SPLIT_VENDOR.SHARED_LIBRARIES.$(l)),$(l).vendor,$(l)))
  endif
endif

ifdef LOCAL_IS_HOST_MODULE
    ifneq ($(my_host_cross),true)
        ALL_MODULES.$(my_register_name).REQUIRED_FROM_HOST := \
            $(strip $(ALL_MODULES.$(my_register_name).REQUIRED_FROM_HOST) $(my_required_modules))
        ALL_MODULES.$(my_register_name).EXPLICITLY_REQUIRED_FROM_HOST := \
            $(strip $(ALL_MODULES.$(my_register_name).EXPLICITLY_REQUIRED_FROM_HOST)\
                $(my_required_modules))
        ALL_MODULES.$(my_register_name).TARGET_REQUIRED_FROM_HOST := \
            $(strip $(ALL_MODULES.$(my_register_name).TARGET_REQUIRED_FROM_HOST)\
                $(LOCAL_TARGET_REQUIRED_MODULES))
    else
        ALL_MODULES.$(my_register_name).REQUIRED_FROM_HOST_CROSS := \
            $(strip $(ALL_MODULES.$(my_register_name).REQUIRED_FROM_HOST_CROSS) $(my_required_modules))
        ALL_MODULES.$(my_register_name).EXPLICITLY_REQUIRED_FROM_HOST_CROSS := \
            $(strip $(ALL_MODULES.$(my_register_name).EXPLICITLY_REQUIRED_FROM_HOST_CROSS)\
                $(my_required_modules))
        ifdef LOCAL_TARGET_REQUIRED_MODULES
            $(call pretty-error,LOCAL_TARGET_REQUIRED_MODULES may not be used from host_cross modules)
        endif
    endif
    ifdef LOCAL_HOST_REQUIRED_MODULES
        $(call pretty-error,LOCAL_HOST_REQUIRED_MODULES may not be used from host modules. Use LOCAL_REQUIRED_MODULES instead)
    endif
else
    ALL_MODULES.$(my_register_name).REQUIRED_FROM_TARGET := \
        $(strip $(ALL_MODULES.$(my_register_name).REQUIRED_FROM_TARGET) $(my_required_modules))
    ALL_MODULES.$(my_register_name).EXPLICITLY_REQUIRED_FROM_TARGET := \
        $(strip $(ALL_MODULES.$(my_register_name).EXPLICITLY_REQUIRED_FROM_TARGET)\
            $(my_required_modules))
    ALL_MODULES.$(my_register_name).HOST_REQUIRED_FROM_TARGET := \
        $(strip $(ALL_MODULES.$(my_register_name).HOST_REQUIRED_FROM_TARGET)\
            $(LOCAL_HOST_REQUIRED_MODULES))
    ifdef LOCAL_TARGET_REQUIRED_MODULES
        $(call pretty-error,LOCAL_TARGET_REQUIRED_MODULES may not be used from target modules. Use LOCAL_REQUIRED_MODULES instead)
    endif
endif
ALL_MODULES.$(my_register_name).EVENT_LOG_TAGS := \
    $(ALL_MODULES.$(my_register_name).EVENT_LOG_TAGS) $(event_log_tags)
ALL_MODULES.$(my_register_name).MAKEFILE := \
    $(ALL_MODULES.$(my_register_name).MAKEFILE) $(LOCAL_MODULE_MAKEFILE)
ifdef LOCAL_MODULE_OWNER
ALL_MODULES.$(my_register_name).OWNER := \
    $(sort $(ALL_MODULES.$(my_register_name).OWNER) $(LOCAL_MODULE_OWNER))
endif
ifdef LOCAL_2ND_ARCH_VAR_PREFIX
ALL_MODULES.$(my_register_name).FOR_2ND_ARCH := true
endif
ALL_MODULES.$(my_register_name).FOR_HOST_CROSS := $(my_host_cross)
ALL_MODULES.$(my_register_name).MODULE_NAME := $(LOCAL_MODULE)
ALL_MODULES.$(my_register_name).COMPATIBILITY_SUITES := $(LOCAL_COMPATIBILITY_SUITE)
ALL_MODULES.$(my_register_name).TEST_CONFIG := $(test_config)
test_config :=

INSTALLABLE_FILES.$(LOCAL_INSTALLED_MODULE).MODULE := $(my_register_name)

##########################################################
# Track module-level dependencies.
# Use $(LOCAL_MODULE) instead of $(my_register_name) to ignore module's bitness.
ALL_DEPS.MODULES := $(ALL_DEPS.MODULES) $(LOCAL_MODULE)
ALL_DEPS.$(LOCAL_MODULE).ALL_DEPS := $(sort \
  $(ALL_MODULES.$(LOCAL_MODULE).ALL_DEPS) \
  $(LOCAL_STATIC_LIBRARIES) \
  $(LOCAL_WHOLE_STATIC_LIBRARIES) \
  $(LOCAL_SHARED_LIBRARIES) \
  $(LOCAL_HEADER_LIBRARIES) \
  $(LOCAL_STATIC_JAVA_LIBRARIES) \
  $(LOCAL_JAVA_LIBRARIES)\
  $(LOCAL_JNI_SHARED_LIBRARIES))

ALL_DEPS.$(LOCAL_MODULE).LICENSE := $(sort $(ALL_DEPS.$(LOCAL_MODULE).LICENSE) $(license_files))

###########################################################
## Take care of my_module_tags
###########################################################

# Keep track of all the tags we've seen.
ALL_MODULE_TAGS := $(sort $(ALL_MODULE_TAGS) $(my_module_tags))

# Add this module name to the tag list of each specified tag.
$(foreach tag,$(my_module_tags),\
    $(eval ALL_MODULE_NAME_TAGS.$(tag) := $$(ALL_MODULE_NAME_TAGS.$(tag)) $(my_register_name)))

###########################################################
## umbrella targets used to verify builds
###########################################################
j_or_n :=
ifneq (,$(filter EXECUTABLES SHARED_LIBRARIES STATIC_LIBRARIES HEADER_LIBRARIES NATIVE_TESTS,$(LOCAL_MODULE_CLASS)))
j_or_n := native
else
ifneq (,$(filter JAVA_LIBRARIES APPS,$(LOCAL_MODULE_CLASS)))
j_or_n := java
endif
endif
ifdef LOCAL_IS_HOST_MODULE
h_or_t := host
ifeq ($(my_host_cross),true)
h_or_hc_or_t := host-cross
else
h_or_hc_or_t := host
endif
else
h_or_hc_or_t := target
h_or_t := target
endif


ifdef j_or_n
$(j_or_n) $(h_or_t) $(j_or_n)-$(h_or_hc_or_t) : $(my_checked_module)
ifneq (,$(filter $(my_module_tags),tests))
$(j_or_n)-$(h_or_t)-tests $(j_or_n)-tests $(h_or_t)-tests : $(my_checked_module)
endif
$(LOCAL_MODULE)-$(h_or_hc_or_t) : $(my_all_targets)
.PHONY: $(LOCAL_MODULE)-$(h_or_hc_or_t)
ifeq ($(j_or_n),native)
$(LOCAL_MODULE)-$(h_or_hc_or_t)$(my_32_64_bit_suffix) : $(my_all_targets)
.PHONY: $(LOCAL_MODULE)-$(h_or_hc_or_t)$(my_32_64_bit_suffix)
endif
endif

###########################################################
# Ensure privileged applications always have LOCAL_PRIVILEGED_MODULE
###########################################################
ifndef LOCAL_PRIVILEGED_MODULE
  ifneq (,$(filter $(TARGET_OUT_APPS_PRIVILEGED)/% $(TARGET_OUT_VENDOR_APPS_PRIVILEGED)/%,$(my_module_path)))
    LOCAL_PRIVILEGED_MODULE := true
  endif
endif
=======
ALL_MODULES += $(LOCAL_MODULE)

# Don't use += on subvars, or else they'll end up being
# recursively expanded.
ALL_MODULES.$(LOCAL_MODULE).CLASS := \
    $(ALL_MODULES.$(LOCAL_MODULE).CLASS) $(LOCAL_MODULE_CLASS)
ALL_MODULES.$(LOCAL_MODULE).PATH := \
    $(ALL_MODULES.$(LOCAL_MODULE).PATH) $(LOCAL_PATH)
ALL_MODULES.$(LOCAL_MODULE).TAGS := \
    $(ALL_MODULES.$(LOCAL_MODULE).TAGS) $(LOCAL_MODULE_TAGS)
ALL_MODULES.$(LOCAL_MODULE).CHECKED := \
    $(ALL_MODULES.$(LOCAL_MODULE).CHECKED) $(LOCAL_CHECKED_MODULE)
ALL_MODULES.$(LOCAL_MODULE).BUILT := \
    $(ALL_MODULES.$(LOCAL_MODULE).BUILT) $(LOCAL_BUILT_MODULE)
ALL_MODULES.$(LOCAL_MODULE).INSTALLED := \
    $(ALL_MODULES.$(LOCAL_MODULE).INSTALLED) $(LOCAL_INSTALLED_MODULE)
ALL_MODULES.$(LOCAL_MODULE).REQUIRED := \
    $(ALL_MODULES.$(LOCAL_MODULE).REQUIRED) $(LOCAL_REQUIRED_MODULES)
ALL_MODULES.$(LOCAL_MODULE).EVENT_LOG_TAGS := \
    $(ALL_MODULES.$(LOCAL_MODULE).EVENT_LOG_TAGS) $(event_log_tags)
ALL_MODULES.$(LOCAL_MODULE).INTERMEDIATE_SOURCE_DIR := \
    $(ALL_MODULES.$(LOCAL_MODULE).INTERMEDIATE_SOURCE_DIR) $(LOCAL_INTERMEDIATE_SOURCE_DIR)

INSTALLABLE_FILES.$(LOCAL_INSTALLED_MODULE).MODULE := $(LOCAL_MODULE)

###########################################################
## Take care of LOCAL_MODULE_TAGS
###########################################################

# Keep track of all the tags we've seen.
ALL_MODULE_TAGS := $(sort $(ALL_MODULE_TAGS) $(LOCAL_MODULE_TAGS))

# Add this module to the tag list of each specified tag.
# Don't use "+=". If the variable hasn't been set with ":=",
# it will default to recursive expansion.
$(foreach tag,$(LOCAL_MODULE_TAGS),\
    $(eval ALL_MODULE_TAGS.$(tag) := \
	    $(ALL_MODULE_TAGS.$(tag)) \
	    $(LOCAL_INSTALLED_MODULE)))

# Add this module name to the tag list of each specified tag.
$(foreach tag,$(LOCAL_MODULE_TAGS),\
    $(eval ALL_MODULE_NAME_TAGS.$(tag) += $(LOCAL_MODULE)))
>>>>>>> 1b0db93f (Merge pull request #122 from kanru/bug1031593)

###########################################################
## NOTICE files
###########################################################

<<<<<<< HEAD
include $(BUILD_NOTICE_FILE)
=======
include $(BUILD_SYSTEM)/notice_files.mk

#:vi noexpandtab
>>>>>>> 1b0db93f (Merge pull request #122 from kanru/bug1031593)
